### 1. **What is TypeScript and how is it different from JavaScript?**

**Answer:**

TypeScript is a statically typed superset of JavaScript developed by Microsoft. It adds optional type annotations, interfaces, enums, generics, and other features to JavaScript, enabling better tooling, scalability, and developer experience.

**Key Differences:**

| Feature | JavaScript | TypeScript |
| --- | --- | --- |
| Type System | Dynamically typed | Statically typed (optional typing) |
| Compilation | Interpreted | Compiled to JS |
| Tooling Support | Good | Excellent (especially in IDEs) |
| ES Features | Limited to ECMAScript version | Can use future ES features with polyfills |
| Error Checking | Runtime | Compile-time |

```
ts
CopyEdit
// JavaScript
function greet(name) {
  return "Hello, " + name;
}

// TypeScript
function greet(name: string): string {
  return "Hello, " + name;
}

```

**Follow-up Q1:** Why is static typing beneficial in large applications?

**A1:**

Static typing helps:

- Catch errors at compile-time rather than runtime
- Enable powerful code completion and refactoring
- Make contracts between components explicit
- Reduce bugs in collaborative projects

---

### ‚úÖ 2. **What are the basic types available in TypeScript?**

**Answer:**

TypeScript supports several primitive and complex types:

```
ts
CopyEdit
// Primitive Types
let id: number = 5;
let username: string = "Alice";
let isAdmin: boolean = true;
let nothing: null = null;
let notDefined: undefined = undefined;

// Special Types
let value: any = "anything";        // disables type checking
let id2: unknown = 123;             // safer than any
let neverVar: never;                // for unreachable code
let something: void = undefined;    // usually return type for functions

```

**Follow-up Q1:** What is the difference between `any` and `unknown`?

**A1:**

| `any` | `unknown` |
| --- | --- |
| Disables all type checks | Must perform checks before using |
| Can cause runtime errors | Safer, but more verbose |

---

### ‚úÖ 3. **What are interfaces in TypeScript?**

**Answer:**

An interface defines the shape of an object. It describes the structure and expected types of its properties.

```
ts
CopyEdit
interface User {
  id: number;
  name: string;
  email?: string; // optional
}

const user1: User = {
  id: 1,
  name: "Prashant"
};

```

**Follow-up Q1:** Can interfaces be extended?

**A1:**

Yes. Interfaces support inheritance.

```
ts
CopyEdit
interface Admin extends User {
  role: string;
}

const admin1: Admin = {
  id: 2,
  name: "Bob",
  role: "Manager"
};

```

---

### ‚úÖ 4. **What are type aliases and how do they differ from interfaces?**

**Answer:**

Type aliases allow you to create a new name for a type:

```
ts
CopyEdit
type UserId = string | number;

type User = {
  id: UserId;
  name: string;
};

```

**Differences from interfaces:**

| Feature | Interface | Type Alias |
| --- | --- | --- |
| Extension | Can extend | Can use intersection (`&`) |
| Declaration merging | Supported | Not supported |
| Use cases | Objects, contracts | Primitives, unions, tuples, etc. |

**Follow-up Q1:** When should you prefer interface over type?

**A1:**

Use `interface` when describing object shapes or contracts for classes. Use `type` for unions, intersections, or mapping primitive types.

---

### ‚úÖ 5. **What are enums in TypeScript?**

**Answer:**

Enums (short for "enumerations") allow you to define a set of named constants. They can be numeric or string-based.

```
ts
CopyEdit
enum Direction {
  Up,
  Down,
  Left,
  Right
}

enum Status {
  Success = "SUCCESS",
  Error = "ERROR"
}

```

**Follow-up Q1:** Can you reverse map numeric enums?

**A1:**

Yes. Numeric enums have a reverse mapping:

```
ts
CopyEdit
enum Color {
  Red,
  Green
}

console.log(Color[0]); // Red
console.log(Color.Red); // 0

```

**Follow-up Q2:** Are string enums reversible?

**A2:**

No. String enums only allow forward mapping.

---

Would you like me to proceed with questions 6‚Äì10 next, covering `functions`, `optional parameters`, `type assertions`, and `generics`?

---

### ‚úÖ **6. What are functions in TypeScript and how do you annotate their types?**

**Answer:**

In TypeScript, functions can have **type annotations** for parameters and return types. This allows for **compile-time type checking** and better IntelliSense.

---

### üîç Syntax:

```
ts
CopyEdit
function add(a: number, b: number): number {
  return a + b;
}

```

- `a: number` ‚Üí argument type
- `: number` ‚Üí return type

---

### üß† Function Expression with Types:

```
ts
CopyEdit
const multiply: (x: number, y: number) => number = (x, y) => x * y;

```

---

**Follow-up Q1:** What happens if you omit the return type?

**A1:** TypeScript will infer the return type based on the `return` statement. However, explicit annotation improves clarity and catches bugs in refactors.

---

**Follow-up Q2:** Can TypeScript functions return `void` or `never`?

**A2:**

- Use `void` when a function does not return a value.
- Use `never` for functions that never return (e.g. throw errors or infinite loops).

```
ts
CopyEdit
function log(msg: string): void {
  console.log(msg);
}

function crash(): never {
  throw new Error("Something went wrong");
}

```

---

### ‚úÖ **7. What are optional and default parameters in TypeScript?**

**Answer:**

Optional parameters allow you to **omit** arguments when calling a function.

Default parameters provide a **fallback value**.

---

### üîç Syntax:

```
ts
CopyEdit
function greet(name: string = "Guest", age?: number): string {
  return `Hello ${name}, Age: ${age ?? "N/A"}`;
}

greet(); // "Hello Guest, Age: N/A"

```

- `age?: number` is optional.
- `name: string = "Guest"` has a default value.

---

**Follow-up Q1:** Can optional parameters come before required ones?

**A1:** ‚ùå No. Optional parameters must come **after** required ones.

```
ts
CopyEdit
// Invalid
function badFunc(a?: string, b: string) {} // ‚ùå

// Valid
function goodFunc(a: string, b?: string) {} // ‚úÖ

```

---

### ‚úÖ **8. What is type assertion in TypeScript?**

**Answer:**

Type assertion lets you **override** TypeScript‚Äôs inferred type. It's used when you know more about the type than TypeScript does.

---

### üîç Syntax:

```
ts
CopyEdit
let someValue: any = "hello";

// Method 1 (angle brackets)
let length1 = (<string>someValue).length;

// Method 2 (as keyword)
let length2 = (someValue as string).length;

```

‚úÖ Use `as` in React/TSX environments (angle brackets conflict with JSX).

---

**Follow-up Q1:** Is type assertion a type cast?

**A1:** No. It does **not change the runtime type**, only the **compile-time type**.

---

**Follow-up Q2:** Can type assertion be used with DOM?

**A2:** Yes, especially useful when accessing DOM elements:

```
ts
CopyEdit
const input = document.getElementById("myInput") as HTMLInputElement;
console.log(input.value);

```

---

### ‚úÖ **9. What are union and intersection types?**

**Answer:**

- **Union types (`|`)**: A variable can be **one of several types**.
- **Intersection types (`&`)**: A variable must satisfy **all combined types**.

---

### üîç Example (Union):

```
ts
CopyEdit
let id: number | string;
id = 101;
id = "abc";

```

### üîç Example (Intersection):

```
ts
CopyEdit
interface Name { name: string; }
interface Age { age: number; }

type Person = Name & Age;

const p: Person = { name: "John", age: 30 };

```

---

**Follow-up Q1:** Can union types be used in functions?

**A1:** Yes, but you must narrow the type:

```
ts
CopyEdit
function logId(id: number | string) {
  if (typeof id === "string") {
    console.log(id.toUpperCase());
  } else {
    console.log(id.toFixed(2));
  }
}

```

---

### ‚úÖ **10. What are generics in TypeScript?**

**Answer:**

Generics provide a way to create **reusable components** that work with **any data type** while preserving type safety.

---

### üîç Syntax:

```
ts
CopyEdit
function identity<T>(arg: T): T {
  return arg;
}

const num = identity<number>(10);
const str = identity<string>("hello");

```

‚úÖ `<T>` is a **type variable**.

---

**Follow-up Q1:** Can you restrict a generic to a specific shape?

**A1:**

Yes, using `extends`:

```
ts
CopyEdit
function logLength<T extends { length: number }>(item: T): void {
  console.log(item.length);
}

```

Now `T` must have a `length` property.

---

**Follow-up Q2:** Can you use generics in interfaces and classes?

**A2:** Yes:

```
ts
CopyEdit
interface Box<T> {
  value: T;
}

class Container<T> {
  constructor(public content: T) {}
}

```

---

Would you like me to continue with **Questions 11‚Äì15** next, covering topics like `tuples`, `readonly`, `keyof`, `typeof`, and `mapped types`?

### You said:

yes please

### ChatGPT said:

Excellent! Let's continue with **Questions 11‚Äì15**, diving deeper into TypeScript features like tuples, `readonly`, `keyof`, `typeof`, and mapped types. These are frequently asked in interviews for intermediate to advanced roles.

---

### ‚úÖ **11. What are tuples in TypeScript?**

**Answer:**

A **tuple** is a special array type in TypeScript where the type of each element is known and fixed.

---

### üîç Syntax:

```
ts
CopyEdit
let user: [string, number];
user = ["Alice", 30]; // ‚úÖ Valid
user = [30, "Alice"]; // ‚ùå Error (wrong order)

```

---

### ‚úÖ Use Case:

Tuples are often used to represent fixed-length heterogeneous data like:

```
ts
CopyEdit
type Response = [string, number];

```

---

**Follow-up Q1:** Can tuples have optional elements?

**A1:**

Yes. You can define optional elements after required ones:

```
ts
CopyEdit
type User = [string, number?, boolean?];

```

---

**Follow-up Q2:** Can tuples be destructured?

**A2:**

Yes:

```
ts
CopyEdit
const [name, age] = ["John", 25];

```

---

### ‚úÖ **12. What is the `readonly` modifier in TypeScript?**

**Answer:**

The `readonly` keyword makes a property or array element immutable after initialization.

---

### üîç Example with Objects:

```
ts
CopyEdit
interface User {
  readonly id: number;
  name: string;
}

const user: User = { id: 1, name: "Alice" };
user.name = "Bob";     // ‚úÖ Allowed
// user.id = 2;        // ‚ùå Error

```

---

### üîç Example with Arrays:

```
ts
CopyEdit
const nums: readonly number[] = [1, 2, 3];
// nums.push(4);      // ‚ùå Error

```

---

**Follow-up Q1:** What‚Äôs the difference between `readonly` array and normal array?

**A1:**

A `readonly` array disallows any mutation methods (`push`, `pop`, etc.). It is **shallowly immutable**.

---

**Follow-up Q2:** Can you use `Readonly<T>` utility type?

**A2:**

Yes. It makes all properties of a type readonly:

```
ts
CopyEdit
type ImmutableUser = Readonly<User>;

```

---

### ‚úÖ **13. What is the `keyof` operator in TypeScript?**

**Answer:**

The `keyof` operator returns a union of all property names (keys) of a given type.

---

### üîç Example:

```
ts
CopyEdit
type User = {
  id: number;
  name: string;
};

type UserKeys = keyof User; // "id" | "name"

```

---

‚úÖ Useful in **generics** for creating safe APIs:

```
ts
CopyEdit
function getProp<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

```

---

**Follow-up Q1:** Can `keyof` be used with union types?

**A1:**

Yes. It returns the **intersection of keys** common to all variants.

```
ts
CopyEdit
type A = { a: string; common: number };
type B = { b: string; common: number };

type C = A | B;
type CommonKeys = keyof C; // "common"

```

---

### ‚úÖ **14. What is the `typeof` operator in TypeScript?**

**Answer:**

The `typeof` operator in TypeScript can be used to **get the type of a variable** at compile time ‚Äî not to be confused with JavaScript‚Äôs runtime `typeof`.

---

### üîç Example:

```
ts
CopyEdit
const user = {
  name: "Alice",
  age: 30,
};

type User = typeof user;
// Equivalent to: { name: string; age: number; }

```

---

**Follow-up Q1:** Can `typeof` be used with functions?

**A1:**

Yes:

```
ts
CopyEdit
function greet(name: string) {
  return `Hello, ${name}`;
}

type GreetFn = typeof greet; // (name: string) => string

```

---

**Follow-up Q2:** What‚Äôs the difference between TypeScript `typeof` and JavaScript `typeof`?

|  | TypeScript | JavaScript |
| --- | --- | --- |
| Usage | Compile-time type extraction | Runtime type checking |
| Output | A type | A string like `"number"` |

---

### ‚úÖ **15. What are mapped types in TypeScript?**

**Answer:**

Mapped types allow you to **create new types** by transforming properties of an existing type.

---

### üîç Example:

```
ts
CopyEdit
type User = {
  id: number;
  name: string;
};

type ReadOnlyUser = {
  readonly [K in keyof User]: User[K];
};

```

‚úÖ Equivalent to:

```
ts
CopyEdit
type ReadOnlyUser = Readonly<User>;

```

---

**Follow-up Q1:** How can you make all properties optional?

**A1:**

```
ts
CopyEdit
type Optional<T> = {
  [K in keyof T]?: T[K];
};

```

‚úÖ Equivalent to:

```
ts
CopyEdit
type Partial<T>

```

---

**Follow-up Q2:** Can you remove `readonly` modifiers using mapped types?

**A2:**

Yes:

```
ts
CopyEdit
type Mutable<T> = {
  -readonly [K in keyof T]: T[K];
};

```

---

These mapped types power utility types like `Partial`, `Required`, `Readonly`, and `Pick`.

---

---

### ‚úÖ **16. What are utility types in TypeScript?**

**Answer:**

**Utility types** are built-in TypeScript types that help you **transform existing types** easily. They are mostly based on **mapped types** and **conditional types**.

---

### üîç Common Utility Types:

| Utility Type | Description |
| --- | --- |
| `Partial<T>` | Makes all properties optional |
| `Required<T>` | Makes all properties required |
| `Readonly<T>` | Makes all properties readonly |
| `Pick<T, K>` | Picks a subset of properties |
| `Omit<T, K>` | Omits selected properties |
| `Record<K, T>` | Creates an object type with specified keys and value types |
| `Exclude<T, U>` | Excludes types from union |
| `Extract<T, U>` | Extracts types from union |
| `ReturnType<T>` | Gets the return type of a function |
| `Parameters<T>` | Gets parameter types as tuple |

---

### üß† Example:

```
ts
CopyEdit
interface User {
  id: number;
  name: string;
  email: string;
}

type UserPreview = Pick<User, "id" | "name">;
type ReadonlyUser = Readonly<User>;

```

---

**Follow-up Q1:** How would you remove a specific property from a type?

**A1:**

Using `Omit<T, K>`:

```
ts
CopyEdit
type NoEmail = Omit<User, "email">;

```

---

**Follow-up Q2:** Can you combine utility types?

**A2:**

Yes. For example:

```
ts
CopyEdit
type EditableUser = Partial<Omit<User, "id">>;

```

---

### ‚úÖ **17. What are conditional types in TypeScript?**

**Answer:**

Conditional types use the ternary operator to **choose one type or another** based on a condition.

---

### üîç Syntax:

```
ts
CopyEdit
T extends U ? X : Y

```

---

### üß† Example:

```
ts
CopyEdit
type IsString<T> = T extends string ? "Yes" : "No";

type A = IsString<string>; // "Yes"
type B = IsString<number>; // "No"

```

‚úÖ Used in advanced libraries like React or utility types like `Exclude<T, U>`.

---

**Follow-up Q1:** What are distributive conditional types?

**A1:**

If `T` is a union, conditional types distribute over each member:

```
ts
CopyEdit
type ToString<T> = T extends number ? `${T}` : never;
type R = ToString<1 | 2>; // "1" | "2"

```

‚úÖ This is a powerful feature for transforming unions.

---

### ‚úÖ **18. What are discriminated unions in TypeScript?**

**Answer:**

A **discriminated union** is a type that consists of multiple object types **sharing a common discriminant (tag)**.

---

### üîç Example:

```
ts
CopyEdit
type Shape =
  | { kind: "circle"; radius: number }
  | { kind: "square"; side: number };

function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.side ** 2;
  }
}

```

‚úÖ TypeScript narrows based on the `kind` field ‚Äî no need for manual type checks.

---

**Follow-up Q1:** What happens if you forget a case?

**A1:** TypeScript won‚Äôt throw an error, but using `never` helps enforce exhaustiveness:

```
ts
CopyEdit
function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.side ** 2;
    default:
      const _exhaustive: never = shape; // Compile error if new case is added
      return _exhaustive;
  }
}

```

---

### ‚úÖ **19. What are custom type guards in TypeScript?**

**Answer:**

Type guards refine the type of a variable inside a block.

A **custom type guard** is a function that returns a **type predicate** like `arg is Type`.

---

### üîç Example:

```
ts
CopyEdit
function isString(value: unknown): value is string {
  return typeof value === "string";
}

function print(value: unknown) {
  if (isString(value)) {
    console.log(value.toUpperCase()); // string methods safe here
  }
}

```

---

**Follow-up Q1:** Why use custom type guards instead of `typeof`?

**A1:**

- You can check custom object shapes, not just primitives.
- Works with interfaces and complex logic.

```
ts
CopyEdit
interface Cat { meow(): void; }
interface Dog { bark(): void; }

function isCat(animal: Cat | Dog): animal is Cat {
  return (animal as Cat).meow !== undefined;
}

```

---

### ‚úÖ **20. What are advanced narrowing techniques in TypeScript?**

**Answer:**

TypeScript uses **narrowing** to refine types based on:

- `typeof`
- `instanceof`
- Equality checks
- Discriminated unions
- Type guards
- Truthy/falsy checks

---

### üîç Example:

```
ts
CopyEdit
function printId(id: number | string | null) {
  if (!id) return;
  if (typeof id === "string") {
    console.log(id.toUpperCase());
  } else {
    console.log(id.toFixed(2));
  }
}

```

‚úÖ TypeScript narrows to appropriate branch based on control flow.

---

**Follow-up Q1:** Can narrowing be combined with custom guards?

**A1:** Yes. This allows complex type safety.

```
ts
CopyEdit
function isDefined<T>(val: T | undefined | null): val is T {
  return val !== undefined && val !== null;
}

```

Now `arr.filter(isDefined)` works correctly in strict mode.

---

Would you like to proceed with **Questions 21‚Äì25** next, covering topics like `this` typing, function overloads, type inference, index signatures, and advanced utility types?

### You said:

yes please

### ChatGPT said:

Perfect! Here's the next set ‚Äî **Questions 21 to 25**, covering the `this` keyword in TypeScript, function overloads, type inference, index signatures, and deeper use of utility types. These questions are common at mid-to-advanced levels and often asked in interviews.

---

### ‚úÖ **21. How is `this` typed in TypeScript and how do you annotate it?**

**Answer:**

In TypeScript, you can explicitly annotate the `this` parameter in a function to specify its expected context. This helps catch errors where the function is called with the wrong `this`.

---

### üîç Syntax:

```
ts
CopyEdit
function sayHello(this: { name: string }) {
  console.log(`Hello, ${this.name}`);
}

```

Note: The `this` parameter is not passed at runtime. It‚Äôs only a compile-time hint.

---

### üß† Use Case in Objects:

```
ts
CopyEdit
const user = {
  name: "Alice",
  greet: sayHello
};

user.greet(); // Hello, Alice

```

If `greet` is called without the correct context, TypeScript shows an error.

---

**Follow-up Q1:** Can you use `this` in arrow functions?

**A1:**

No ‚Äî arrow functions **do not have their own `this`**; they capture it from the surrounding context.

```
ts
CopyEdit
const obj = {
  name: "Bob",
  greet: () => {
    console.log(this.name); // undefined
  }
};

```

---

**Follow-up Q2:** Can `this` be typed in class methods?

**A2:**

Yes, but it's rarely needed because class methods automatically bind `this` to instances.

---

### ‚úÖ **22. What are function overloads in TypeScript?**

**Answer:**

**Function overloads** allow you to define multiple type signatures for the same function, enabling strong typing for different argument combinations.

---

### üîç Syntax:

```
ts
CopyEdit
function combine(a: number, b: number): number;
function combine(a: string, b: string): string;
function combine(a: any, b: any): any {
  return a + b;
}

```

Only the last implementation contains the logic ‚Äî previous lines are **overload signatures**.

---

**Follow-up Q1:** Can overloads differ in return type?

**A1:** Yes, as long as the argument types help determine which one applies:

```
ts
CopyEdit
function parse(input: string): string[];
function parse(input: number): number[];
function parse(input: any): any[] {
  return Array.isArray(input) ? input : [input];
}

```

---

**Follow-up Q2:** Why not use union types instead?

**A2:**

Union types work for simple cases, but overloads offer better **autocomplete**, **type safety**, and **distinct return types** per input signature.

---

### ‚úÖ **23. What is type inference in TypeScript?**

**Answer:**

**Type inference** means that TypeScript automatically deduces a variable‚Äôs type based on the value assigned ‚Äî even if you don‚Äôt annotate it explicitly.

---

### üîç Example:

```
ts
CopyEdit
let num = 42;      // Inferred as number
let name = "John"; // Inferred as string

```

---

**Function Return Type Inference:**

```
ts
CopyEdit
function square(n: number) {
  return n * n;
}
// Return type is inferred as number

```

---

**Follow-up Q1:** What happens if there is no return?

**A1:** TypeScript infers `void`.

---

**Follow-up Q2:** When should you use explicit types over inference?

**A2:**

Use explicit types:

- For exported APIs
- For function parameters
- When clarity is essential

---

### ‚úÖ **24. What are index signatures in TypeScript?**

**Answer:**

Index signatures allow you to define object types with **dynamic property keys** of a certain type.

---

### üîç Example:

```
ts
CopyEdit
interface Dictionary {
  [key: string]: string;
}

const colors: Dictionary = {
  red: "#f00",
  blue: "#00f"
};

```

‚úÖ Useful when keys are not fixed but values must follow a type pattern.

---

**Follow-up Q1:** Can index signatures be numeric?

**A1:** Yes:

```
ts
CopyEdit
interface NumericArray {
  [index: number]: number;
}

```

---

**Follow-up Q2:** Can index signatures conflict with fixed keys?

**A2:**

Yes, all explicitly defined keys must be compatible with the value type of the index signature.

```
ts
CopyEdit
interface Example {
  [key: string]: number;
  name: string; // ‚ùå Error: string is not assignable to number
}

```

---

### ‚úÖ **25. What are advanced utility types like `ReturnType`, `Parameters`, and `InstanceType`?**

**Answer:**

These utility types extract structural information from existing types or values.

---

### üîç Examples:

```
ts
CopyEdit
function greet(name: string, age: number): string {
  return `Hello ${name}, age ${age}`;
}

type GreetReturn = ReturnType<typeof greet>; // string
type GreetParams = Parameters<typeof greet>; // [string, number]

class Person {
  constructor(public name: string) {}
}

type PersonInstance = InstanceType<typeof Person>; // Person

```

---

**Follow-up Q1:** Can these be used to build wrappers?

**A1:** Yes! These types are useful for building **HOCs**, decorators, and API wrappers:

```
ts
CopyEdit
function withLogging<T extends (...args: any[]) => any>(fn: T): (...args: Parameters<T>) => ReturnType<T> {
  return (...args) => {
    console.log("Calling:", args);
    return fn(...args);
  };
}

```

---

Would you like me to continue with **Questions 26‚Äì30**, where we can go deeper into template literal types, infer keyword, declaration merging, type compatibility, and ambient declarations?

### You said:

yes

### ChatGPT said:

Awesome! Now let‚Äôs continue with **Questions 26‚Äì30**, where we dive into some of TypeScript‚Äôs most powerful advanced type system features: template literal types, the `infer` keyword, declaration merging, type compatibility, and ambient declarations.

---

### ‚úÖ **26. What are template literal types in TypeScript?**

**Answer:**

Template literal types allow you to create new string-like types by combining literal strings and union types.

---

### üîç Syntax:

```
ts
CopyEdit
type Greeting = `Hello, ${string}`;

```

‚úÖ Useful for **creating structured strings**, like route paths, event names, etc.

---

### üß† Example:

```
ts
CopyEdit
type Color = "red" | "blue";
type Shades = "light" | "dark";

type ColorVariant = `${Shades}-${Color}`;
// "light-red" | "light-blue" | "dark-red" | "dark-blue"

```

---

**Follow-up Q1:** Can template literals work with numbers?

**A1:** Yes. TypeScript converts the union to a string:

```
ts
CopyEdit
type Column = `col-${1 | 2 | 3}`; // "col-1" | "col-2" | "col-3"

```

---

**Follow-up Q2:** Can template literals be used in conditional types?

**A2:** Absolutely. They are powerful when used with `infer`, `extends`, or utility types for pattern matching:

```
ts
CopyEdit
type EventHandler<T> = T extends `on${infer E}` ? E : never;

type X = EventHandler<"onClick">; // "Click"

```

---

### ‚úÖ **27. What is the `infer` keyword in TypeScript?**

**Answer:**

`infer` allows you to **extract a type within a conditional type**. It's used when defining a type but want to infer some part of it automatically.

---

### üîç Example:

```
ts
CopyEdit
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

```

‚úÖ Here, `infer R` extracts the return type `R` from a function type.

---

**Follow-up Q1:** Can `infer` be used multiple times?

**A1:** Yes, but it's limited to single inference per clause:

```
ts
CopyEdit
type Params<T> = T extends (a: infer A, b: infer B) => any ? [A, B] : never;

```

---

**Follow-up Q2:** Can `infer` be nested?

**A2:** Yes ‚Äî `infer` can be used inside nested conditionals to recursively extract and transform types:

```
ts
CopyEdit
type DeepArray<T> = T extends (infer U)[] ? DeepArray<U> : T;
type A = DeepArray<number[][]>; // number

```

---

### ‚úÖ **28. What is declaration merging in TypeScript?**

**Answer:**

Declaration merging occurs when **two declarations with the same name** are merged by the compiler into a single entity.

---

### üîç Example with Interfaces:

```
ts
CopyEdit
interface Person {
  name: string;
}
interface Person {
  age: number;
}

const p: Person = {
  name: "Alice",
  age: 30
};

```

‚úÖ Both interfaces are merged into one: `{ name: string; age: number }`

---

### Also supported for:

- `namespaces`
- `functions + namespaces`
- `classes + namespaces`
- `enums + namespaces`

---

**Follow-up Q1:** Can declaration merging be used for extending libraries?

**A1:** Yes! It's often used to **extend types in third-party libraries**:

```
ts
CopyEdit
declare module "express" {
  interface Request {
    user?: { id: string };
  }
}

```

---

**Follow-up Q2:** What happens if the declarations are incompatible?

**A2:** TypeScript will throw a type conflict error if merged declarations have incompatible types.

---

### ‚úÖ **29. What is type compatibility in TypeScript?**

**Answer:**

TypeScript uses **structural typing**, meaning types are compatible based on their shape, not their names.

---

### üîç Example:

```
ts
CopyEdit
interface Point2D {
  x: number;
  y: number;
}

interface Point3D {
  x: number;
  y: number;
  z: number;
}

let p2d: Point2D = { x: 10, y: 20 };
let p3d: Point3D = { x: 10, y: 20, z: 30 };

p2d = p3d; // ‚úÖ OK ‚Äî compatible
// p3d = p2d; ‚ùå Error ‚Äî missing z

```

---

**Follow-up Q1:** What about functions ‚Äî are return types checked?

**A1:** Yes. Function parameters and return values must match for compatibility.

```
ts
CopyEdit
type A = (x: number) => void;
type B = (x: number, y: number) => void;

let fn: A = (x) => {}; // ‚úÖ OK
let fn2: B = fn; // ‚ùå Error (missing argument y)

```

---

**Follow-up Q2:** Is class compatibility structural or nominal?

**A2:** Still structural ‚Äî even unrelated classes are compatible if they share the same shape.

---

### ‚úÖ **30. What are ambient declarations in TypeScript?**

**Answer:**

Ambient declarations **describe types and variables defined elsewhere** (like global variables or third-party libraries).

---

### üîç Syntax:

```
ts
CopyEdit
declare let $: any; // jQuery
declare module "lodash"; // External module

```

‚úÖ Often found in `.d.ts` files ‚Äî which **don‚Äôt emit JavaScript**, only declare type information.

---

**Follow-up Q1:** Where are ambient declarations used?

**A1:**

- Global scripts (`declare var`, `declare global`)
- Type definitions for libraries (`@types/`)
- Custom global config or constants

---

**Follow-up Q2:** How to extend existing declarations?

**A2:**

You can merge declarations using `declare module`:

```
ts
CopyEdit
declare module "express" {
  interface Request {
    user?: { id: string };
  }
}

```

‚úÖ Useful when extending libraries without modifying the source.

### **31. What are advanced narrowing techniques in TypeScript?**

**Answer:**

**Advanced narrowing** refers to techniques TypeScript uses to deduce more specific types from a union type based on runtime checks.

---

### üîç Common Narrowing Techniques:

| Technique | Example |
| --- | --- |
| `typeof` check | `typeof x === "string"` |
| `instanceof` check | `x instanceof Date` |
| `in` operator | `"prop" in obj` |
| Literal comparison | `x === "value"` |
| Truthy/falsy checks | `if (x)` |
| Custom type guards | `function isFoo(x): x is Foo` |

---

### üß† Example:

```
ts
CopyEdit
type Shape = { kind: "circle"; radius: number } | { kind: "square"; side: number };

function area(shape: Shape): number {
  if (shape.kind === "circle") return Math.PI * shape.radius ** 2;
  return shape.side ** 2;
}

```

‚úÖ `kind` is a discriminant and allows safe narrowing inside the function.

---

**Follow-up Q1:** What happens if you check a property that doesn't exist?

**A1:** If the key doesn‚Äôt exist in all union members, TypeScript will error unless you're using a type guard:

```
ts
CopyEdit
if ("radius" in shape) {
  // Type narrowed to circle
}

```

---

**Follow-up Q2:** Can narrowing be combined?

**A2:** Yes, advanced logic often involves combining multiple narrowing techniques:

```
ts
CopyEdit
if (typeof x === "object" && x !== null && "prop" in x) {
  // Safe to access x.prop
}

```

---

### ‚úÖ **32. What are custom type predicates in TypeScript?**

**Answer:**

A **type predicate** is a return type in a function that tells TypeScript the function **confirms a type**.

---

### üîç Syntax:

```
ts
CopyEdit
function isString(value: any): value is string {
  return typeof value === "string";
}

```

‚úÖ TypeScript narrows type within the `if` block based on the return value of the function.

---

### üß† Example:

```
ts
CopyEdit
function printLength(value: string | number) {
  if (isString(value)) {
    console.log(value.length); // Narrowed to string
  }
}

```

---

**Follow-up Q1:** Can you use predicates on custom types?

**A1:**

```
ts
CopyEdit
interface Dog { bark(): void; }
interface Cat { meow(): void; }

function isDog(animal: Dog | Cat): animal is Dog {
  return (animal as Dog).bark !== undefined;
}

```

‚úÖ Very useful when working with complex types.

---

### ‚úÖ **33. What is the `infer` keyword and how is it used in type inference?**

**Answer:**

`infer` is used inside a conditional type to **declare a placeholder type** that can be inferred from some other type.

---

### üîç Basic Use Case:

```
ts
CopyEdit
type ElementType<T> = T extends (infer U)[] ? U : never;

type A = ElementType<number[]>; // number

```

‚úÖ Helps extract types from generics, especially for mapped types and API responses.

---

**Follow-up Q1:** Can you infer return types?

**A1:**

```
ts
CopyEdit
type Return<T> = T extends (...args: any[]) => infer R ? R : never;

```

---

**Follow-up Q2:** Can `infer` be used multiple times?

**A2:** You can use multiple `infer` statements in separate conditionals but **not inside the same conditional clause**.

---

### ‚úÖ **34. How can you implement conditional rendering types in TypeScript?**

**Answer:**

Conditional rendering types mimic runtime logic at the type level ‚Äî switching between types depending on a condition.

---

### üîç Example:

```
ts
CopyEdit
type Status = "loading" | "success" | "error";

type ResponseType<T extends Status> =
  T extends "loading" ? null :
  T extends "error" ? { error: string } :
  { data: string };

```

‚úÖ You can now define UI props like:

```
ts
CopyEdit
type Props<T extends Status> = {
  status: T;
  response: ResponseType<T>;
};

```

---

**Follow-up Q1:** Can this be used with generics?

**A1:** Yes ‚Äî this pattern is frequently used in API response modeling, form validation states, etc.

---

**Follow-up Q2:** What are real-world uses?

**A2:** This is common in component design, especially with discriminated union props and reusable logic.

---

### ‚úÖ **35. How do you define and use custom error types in TypeScript?**

**Answer:**

You can define custom error types using `class` and leverage the built-in `Error` class for compatibility.

---

### üîç Example:

```
ts
CopyEdit
class NotFoundError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "NotFoundError";
  }
}

function fetchUser(id: number): string {
  if (id !== 1) throw new NotFoundError("User not found");
  return "Alice";
}

```

‚úÖ Works seamlessly with `try...catch` and `instanceof`.

---

**Follow-up Q1:** How to type errors in catch blocks?

**A1:** In strict mode, TypeScript doesn‚Äôt assume the type in a catch block:

```
ts
CopyEdit
try {
  // something
} catch (err: unknown) {
  if (err instanceof NotFoundError) {
    console.log(err.message);
  }
}

```

---

**Follow-up Q2:** Can you use union types for custom error models?

**A2:**

```
ts
CopyEdit
type AppError = NotFoundError | ValidationError | AuthError;

```

Then handle via type guards or `instanceof`.

---

Would you like to continue with **Questions 36‚Äì40**, covering advanced mapped types, intersection types, recursive types, module augmentation, and type branding?

### You said:

yes please

### ChatGPT said:

Excellent! Let's now proceed with **Questions 36‚Äì40**, which explore advanced type composition techniques in TypeScript ‚Äî covering mapped types, intersections, recursive types, module augmentation, and type branding. These are highly useful for building scalable, reusable types in real-world applications.

---

### ‚úÖ **36. What are mapped types in TypeScript and how are they used?**

**Answer:**

Mapped types allow you to **create new types based on existing ones** by transforming properties using `keyof` and `in`.

---

### üîç Basic Syntax:

```
ts
CopyEdit
type ReadOnly<T> = {
  readonly [K in keyof T]: T[K];
};

```

This creates a new type where **all properties of `T` are readonly**.

---

### üß† Example:

```
ts
CopyEdit
interface User {
  id: number;
  name: string;
}

type ReadOnlyUser = ReadOnly<User>;
// Equivalent to:
// { readonly id: number; readonly name: string; }

```

---

**Follow-up Q1:** Can you remove `readonly` or optional with mapped types?

**A1:** Yes! Use modifiers:

```
ts
CopyEdit
type Mutable<T> = {
  -readonly [K in keyof T]: T[K];
};

type Required<T> = {
  [K in keyof T]-?: T[K];
};

```

---

**Follow-up Q2:** How do you combine mapped types with generics?

**A2:** They work great with generics, especially for creating:

- DTOs (Data Transfer Objects)
- Partial/Required schemas
- Form validation structures

---

### ‚úÖ **37. What are intersection types in TypeScript and how do they work?**

**Answer:**

Intersection types (`&`) combine **multiple types into one**. The resulting type has all the properties of the intersected types.

---

### üîç Syntax:

```
ts
CopyEdit
type A = { id: number };
type B = { name: string };
type C = A & B; // { id: number; name: string }

```

---

### üß† Use Case:

```
ts
CopyEdit
interface Timestamped {
  createdAt: Date;
  updatedAt: Date;
}

interface Product {
  id: number;
  title: string;
}

type TimestampedProduct = Product & Timestamped;

```

‚úÖ Used to **extend multiple types without inheritance**.

---

**Follow-up Q1:** What if the properties conflict?

**A1:** The type will become **incompatible** if intersected types have conflicting property types:

```
ts
CopyEdit
type A = { id: number };
type B = { id: string };
type C = A & B; // ‚ùå never

```

---

**Follow-up Q2:** When should you use intersection vs. interface `extends`?

**A2:** Use `extends` for inheritance. Use `&` when **merging unrelated types** or composing utility types.

---

### ‚úÖ **38. What are recursive types in TypeScript and when should they be used?**

**Answer:**

Recursive types are **types that refer to themselves**. They're often used to model **deeply nested data**, like trees or nested JSON.

---

### üîç Example: Tree

```
ts
CopyEdit
interface TreeNode {
  value: string;
  children?: TreeNode[];
}

```

---

### üîç Example: DeepPartial

```
ts
CopyEdit
type DeepPartial<T> = {
  [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];
};

```

‚úÖ This makes every property (including nested ones) optional ‚Äî useful for forms or PATCH APIs.

---

**Follow-up Q1:** What is the danger with recursive types?

**A1:** They can **cause infinite recursion** if not carefully structured. Be sure to **terminate** with base types.

---

**Follow-up Q2:** Can recursive types work with mapped or conditional types?

**A2:** Yes ‚Äî that's how libraries like `zod`, `io-ts`, and `class-validator` model complex data structures.

---

### ‚úÖ **39. What is module augmentation in TypeScript and how is it done?**

**Answer:**

**Module augmentation** allows you to **extend types or modules** without modifying the original code ‚Äî especially third-party libraries.

---

### üîç Example: Extending Express Request

```
ts
CopyEdit
// my-express-types.d.ts
import "express";

declare module "express" {
  interface Request {
    user?: { id: string; role: string };
  }
}

```

‚úÖ Now `req.user` is recognized throughout your app.

---

**Follow-up Q1:** What is the difference between declaration merging and module augmentation?

**A1:**

- Declaration merging works within the same file or global scope.
- Module augmentation is used to **extend external modules** or packages.

---

**Follow-up Q2:** When do you need to use `declare module`?

**A2:** When the original module is external (e.g., from `node_modules`) and you want to **add types to it safely**.

---

### ‚úÖ **40. What is type branding (aka nominal typing) in TypeScript?**

**Answer:**

Type branding is a trick to enforce **nominal typing** in TypeScript (which is structurally typed by default).

---

### üîç Use Case:

```
ts
CopyEdit
type UserId = string & { __brand: "UserId" };
type ProductId = string & { __brand: "ProductId" };

function getUser(id: UserId) { /*...*/ }

const userId = "123" as UserId;
getUser(userId); // ‚úÖ

const productId = "456" as ProductId;
getUser(productId); // ‚ùå Error: incompatible types

```

‚úÖ Prevents accidental misuse of **logically different values** with same structure (like two `string` IDs).

---

**Follow-up Q1:** Is this a runtime check?

**A1:** No ‚Äî branding is purely **at the type level**. It doesn‚Äôt affect the runtime value.

---

**Follow-up Q2:** When should you use type branding?

**A2:**

- IDs (e.g., `UserId`, `OrderId`)
- Opaque tokens
- Domain-specific fields

---

Let me know if you'd like to proceed with **Questions 41‚Äì45**, which include TypeScript types for functional programming (e.g. curry, pipe), tuple manipulation, variadic types, discriminated unions, and exhaustive checks.

### You said:

yes

### ChatGPT said:

Perfect! Let‚Äôs now cover **Questions 41‚Äì45**, diving into functional patterns with TypeScript like currying, variadic tuples, tuple manipulation, discriminated unions, and enforcing exhaustive checks. These are some of the most advanced and powerful features in the language.

---

### ‚úÖ **41. How do you represent curried functions in TypeScript?**

**Answer:**

A **curried function** is a function that returns another function until all arguments are received.

---

### üîç Example:

```
ts
CopyEdit
function multiply(a: number): (b: number) => number {
  return (b) => a * b;
}

const double = multiply(2);
console.log(double(5)); // 10

```

---

### üîç Type Signature:

```
ts
CopyEdit
type Curried<T> = T extends (...args: [infer A, ...infer R])
  ? (arg: A) => Curried<(...args: R) => ReturnType<T>>
  : ReturnType<T>;

```

‚úÖ Works recursively to break down a multi-arg function.

---

**Follow-up Q1:** Can you curry variadic functions?

**A1:** Not fully ‚Äî TypeScript doesn‚Äôt yet support true runtime-level variadic currying. You have to limit the number of arguments or use libraries like `lodash.curry`.

---

**Follow-up Q2:** Why curry in the first place?

**A2:** It‚Äôs a functional pattern useful for:

- Partial application
- Better composition
- Enhanced testability

---

### ‚úÖ **42. What are variadic tuple types and how are they useful?**

**Answer:**

**Variadic tuples** allow you to define tuples with **dynamic but typed** rest parameters.

---

### üîç Syntax:

```
ts
CopyEdit
type Prepend<T extends any[], U> = [U, ...T];

type Args<T> = [...T, string];

```

---

### üß† Example:

```
ts
CopyEdit
function logArgs<T extends any[]>(...args: [...T, number]): void {
  console.log(...args);
}

logArgs("user", 42); // ‚úÖ string, number
logArgs(1, 2, 3);    // ‚úÖ

```

‚úÖ Used in utility types, function composition, decorators.

---

**Follow-up Q1:** Can you reverse a tuple using variadic types?

**A1:** Yes, using recursion:

```
ts
CopyEdit
type Reverse<T extends any[]> = T extends [infer A, ...infer R]
  ? [...Reverse<R>, A]
  : [];

```

---

### ‚úÖ **43. How do you perform tuple element manipulation in TypeScript?**

**Answer:**

Tuple manipulation includes:

- **Accessing elements**
- **Mapping or filtering**
- **Reversing**
- **Replacing types at a specific position**

---

### üîç Example: Replace Nth Element

```
ts
CopyEdit
type ReplaceAt<T extends any[], Index extends number, New> = {
  [K in keyof T]: K extends `${Index}` ? New : T[K];
};

```

---

### Example: Extract First

```
ts
CopyEdit
type First<T extends any[]> = T extends [infer A, ...any[]] ? A : never;

```

‚úÖ Useful for building composable types.

---

**Follow-up Q1:** Can you get the length of a tuple?

**A1:**

```
ts
CopyEdit
type Length<T extends any[]> = T["length"];

```

---

**Follow-up Q2:** Can you type a rest parameter tuple with metadata?

**A2:** Yes ‚Äî with labeled tuples:

```
ts
CopyEdit
type UserArgs = [id: string, age: number];

```

---

### ‚úÖ **44. What are discriminated unions and how are they used in TypeScript?**

**Answer:**

A **discriminated union** uses a common literal field (`tag`, `type`, `kind`, etc.) to distinguish among variants of a union type.

---

### üîç Example:

```
ts
CopyEdit
type Circle = { kind: "circle"; radius: number };
type Square = { kind: "square"; side: number };

type Shape = Circle | Square;

function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle": return Math.PI * shape.radius ** 2;
    case "square": return shape.side ** 2;
  }
}

```

‚úÖ Safe, type-aware pattern matching.

---

**Follow-up Q1:** What happens if you forget a case?

**A1:** You can use **exhaustiveness checks**:

```
ts
CopyEdit
function assertNever(x: never): never {
  throw new Error("Unhandled case: " + x);
}

switch (shape.kind) {
  case "circle": return shape.radius;
  case "square": return shape.side;
  default: return assertNever(shape); // ‚úÖ Catches missing types
}

```

---

### ‚úÖ **45. How do you enforce exhaustive checks in TypeScript using `never`?**

**Answer:**

Use a function that accepts a `never` type. This ensures all possible cases in a discriminated union are handled.

---

### üîç Example:

```
ts
CopyEdit
function assertNever(x: never): never {
  throw new Error("Unhandled value: " + x);
}

function getStatusMessage(status: "success" | "error" | "loading") {
  switch (status) {
    case "success": return "Done!";
    case "error": return "Oops!";
    case "loading": return "Loading...";
    default: return assertNever(status); // ‚úÖ Forces full coverage
  }
}

```

‚úÖ Helps in **refactoring-safe switch statements**.

---

**Follow-up Q1:** What if a new status is added?

**A1:** TypeScript will raise an error at `assertNever` because the switch no longer exhausts all options.

---

**Follow-up Q2:** Can this be used outside `switch`?

**A2:** Yes, any place you're working with unions and want to **statically enforce** full coverage.

---

Would you like to continue with **Questions 46‚Äì50**, covering utility types like `Omit`, `Exclude`, `ReturnType`, advanced interface merging, and TypeScript‚Äôs limitations and best practices?

### You said:

yes please

### ChatGPT said:

Great! Let's finish with **Questions 46‚Äì50**, covering essential utility types, interface merging, declaration merging, TypeScript limitations, and best practices. These are advanced topics that often appear in high-level interviews or in scalable TypeScript codebases.

---

### ‚úÖ **46. What are TypeScript utility types and how are they used?**

**Answer:**

**Utility types** are built-in TypeScript helpers that transform existing types into new forms ‚Äî without rewriting them.

---

### üîç Common Utility Types:

| Utility | Purpose | Example |
| --- | --- | --- |
| `Partial<T>` | Makes all properties optional | `Partial<{ a: string }>` ‚Üí `{ a?: string }` |
| `Required<T>` | Makes all properties required | `Required<{ a?: string }>` ‚Üí `{ a: string }` |
| `Readonly<T>` | Makes all properties read-only | `Readonly<{ a: number }>` ‚Üí `{ readonly a: number }` |
| `Pick<T, K>` | Picks a subset of properties | `Pick<User, "id" |
| `Omit<T, K>` | Excludes properties | `Omit<User, "password">` |
| `Record<K, T>` | Creates object with keys `K` and values `T` | `Record<string, number>` |
| `ReturnType<T>` | Extracts return type of a function | `ReturnType<() => string>` ‚Üí `string` |
| `Exclude<T, U>` | Excludes union members | `Exclude<"a" |

---

### üß† Example:

```
ts
CopyEdit
type User = { id: number; name: string; password: string };
type PublicUser = Omit<User, "password">;

```

‚úÖ Useful when building DTOs, GraphQL types, or Redux state transformations.

---

**Follow-up Q1:** Can utility types be composed?

**A1:** Yes! You can nest them:

```
ts
CopyEdit
type OptionalReadOnly = Readonly<Partial<User>>;

```

---

**Follow-up Q2:** Can you create custom utility types?

**A2:** Absolutely. Here's one:

```
ts
CopyEdit
type Nullable<T> = {
  [K in keyof T]: T[K] | null;
};

```

---

### ‚úÖ **47. What is interface merging in TypeScript?**

**Answer:**

**Interface merging** occurs when TypeScript **automatically merges multiple declarations** with the same interface name.

---

### üîç Example:

```
ts
CopyEdit
interface User {
  id: number;
}

interface User {
  name: string;
}

// Result:
const user: User = { id: 1, name: "Alice" };

```

‚úÖ All properties are combined. Useful for declaration files and extending third-party modules.

---

**Follow-up Q1:** What happens with method conflicts?

**A1:** The last-declared method signature wins. Earlier ones are overridden, not merged like properties.

---

**Follow-up Q2:** Can this be used for extending libraries?

**A2:** Yes, interface merging is often used to augment libraries like Express:

```
ts
CopyEdit
declare global {
  interface Window {
    customVar: string;
  }
}

```

---

### ‚úÖ **48. What are the limitations of TypeScript?**

**Answer:**

While TypeScript offers static typing, it **doesn‚Äôt guarantee runtime safety**, and has limitations:

---

### ‚ùå Key Limitations:

1. **Runtime Type Safety Not Enforced**
    - Types are removed at compile time.
2. **No Nominal Typing (without branding)**
    - TypeScript is **structural** by default.
3. **Complex Types Become Unreadable**
    - Conditional + mapped types can create difficult-to-debug scenarios.
4. **Third-Party Type Mismatch**
    - External libraries might have **incomplete or incorrect types**.
5. **Slow Compilation in Large Codebases**
    - Especially with incremental builds or `-watch` mode.

---

**Follow-up Q1:** How to solve runtime safety?

**A1:** Use runtime validation libraries:

- `zod`, `io-ts`, `runtypes`, `class-validator`

---

**Follow-up Q2:** Why doesn't TS enforce strict runtime types?

**A2:** TypeScript is designed to be a superset of JavaScript ‚Äî which is dynamically typed. It **augments**, but does not replace, runtime behavior.

---

### ‚úÖ **49. What are some best practices for using TypeScript in large-scale applications?**

**Answer:**

Here are **proven practices** for maintainability and scalability:

---

### ‚úÖ Coding Best Practices:

1. **Use strict mode**: Enables `noImplicitAny`, `strictNullChecks`, etc.
2. **Avoid `any`**: Use `unknown`, or better ‚Äî narrow the type.
3. **Leverage `type` + `interface` appropriately**:
    - `type` for unions, intersections, mapped types
    - `interface` for object-like structures and extending
4. **Prefer `readonly` and `const`**: Immutability improves predictability.
5. **Use descriptive generics**: Avoid `<T, U>` in favor of `<Item, Response>`.

---

### ‚úÖ Architecture Best Practices:

1. **Split code into modules and types**.
2. **Use DTOs** for validation and serialization.
3. **Validate runtime input** with schema tools.
4. **Define shared types for API requests/responses**.

---

**Follow-up Q1:** How do you enforce strict rules in teams?

**A1:** Use ESLint + TypeScript plugin + Prettier + CI checks.

---

**Follow-up Q2:** Can you mix JS and TS files?

**A2:** Yes, but it's discouraged in large apps. Prefer fully TS with gradual migration via `allowJs`.

---

### ‚úÖ **50. How do you approach converting a JavaScript project to TypeScript?**

**Answer:**

Migration to TypeScript is best done **incrementally**, ensuring minimal disruption to the existing codebase.

---

### üõ†Ô∏è Step-by-Step Migration Plan:

1. **Set up `tsconfig.json`** with `allowJs: true`
2. **Rename files from `.js` to `.ts`**
3. **Add type definitions (`@types/...`)**
4. **Start typing modules incrementally** using:
    - `any` or `unknown` temporarily
    - `JSDoc` annotations if needed
5. **Gradually enable strict checks** like:
    - `noImplicitAny`, `strictNullChecks`
6. **Refactor**: Replace dynamic logic with typed utilities
7. **Validate integration** with test cases and linting

---

**Follow-up Q1:** How to handle 3rd-party JS libraries?

**A1:** Use:

- `@types/libname`
- Or write your own `.d.ts` declaration file

---

**Follow-up Q2:** Should I rewrite everything?

**A2:** No ‚Äî prioritize critical modules (auth, business logic), then expand outward.
